# **A Comparative Analysis of Open-Source Elixir/Erlang Observability and Debugging Tools Against ex\_dbg**

### **1\. Executive Summary**

ex\_dbg is presented as a comprehensive, integrated debugging and observability framework specifically designed for Elixir, offering profound insights into the behavior of the BEAM (Erlang Virtual Machine) runtime. Its core value proposition lies in its ability to provide extensive process, message, GenServer state, and function call tracing. This data is then consolidated into an in-memory, queryable event store, known as TraceDB, which leverages Erlang Term Storage (ETS) tables. This architecture facilitates advanced debugging capabilities, including a "time-travel" feature that allows for the inspection of historical states, particularly beneficial for LiveView applications and other stateful GenServer processes. A particularly innovative aspect of ex\_dbg is its direct integration with an external AI system, Tidewave, which enables natural language queries for runtime analysis, streamlining the diagnostic process.

A thorough review of the current open-source landscape reveals that no single existing tool fully replicates the extensive breadth and deep integration offered by ex\_dbg. Open-source alternatives tend to be specialized: some provide excellent debugging capabilities tailored for LiveView applications (e.g., LiveDebugger, TimeTravel), others focus on lower-level BEAM tracing and profiling (e.g., Erlang Doctor, Rexbug, Trace Tool Builder, fprof), and a third category is dedicated to distributed tracing and Application Performance Monitoring (APM) frameworks (e.g., OpenTelemetry, OpenTracing/OTTER).

Significant functional gaps persist within the open-source ecosystem when compared to ex\_dbg. These include a lack of robust, generalized GenServer state history and time-travel debugging capabilities that extend beyond LiveView-specific assigns. Furthermore, the integrated, queryable event and state database, as embodied by ex\_dbg's TraceDB, represents a unique consolidation of diverse runtime data that is not found in existing open-source tracing solutions. Perhaps the most notable void is the absence of direct, AI-driven runtime analysis, where natural language queries can be used to interact with and interpret live system data.

Organizations seeking to achieve ex\_dbg-like functionality using open-source software would likely need to adopt a multi-faceted approach. This would involve combining several specialized tools to cover different aspects of ex\_dbg's feature set. Critically, substantial custom development would be necessary to bridge the identified gaps, especially for implementing a generic GenServer state history, establishing a unified and queryable data store, and developing any form of AI-driven runtime analysis. Adopting Elixir's telemetry library for consistent instrumentation across various application components would serve as a foundational best practice for such an endeavor.

### **2\. Understanding ex\_dbg: A Holistic Observability Framework**

ex\_dbg is architected as a comprehensive framework designed to provide deep observability into the intricacies of the BEAM VM. Its design emphasizes a modular approach, segmenting capabilities into distinct layers that collectively offer a powerful debugging and analysis environment.

#### **Core Capabilities: Process, Message, State, and Code Tracing**

At its foundation, ex\_dbg incorporates a suite of specialized data collectors to capture a wide array of runtime events. The ProcessObserver is responsible for monitoring the lifecycle of processes, including their spawning and termination, and for tracking the overall supervision tree, which is crucial for understanding application resilience. The MessageInterceptor captures inter-process communication, specifically focusing on message send and receive events. This component leverages the :dbg Erlang tracing utility, indicating a deliberate design choice to build upon established, low-level BEAM tracing primitives for efficient and comprehensive data acquisition. This approach suggests that ex\_dbg prioritizes leveraging battle-tested tracing mechanisms rather than developing new VM-level instrumentation, thereby shifting the development complexity towards sophisticated data aggregation, storage, and analysis.

The StateRecorder is a key differentiator, designed to track changes in GenServer states. It achieves this through the use of Elixir macros or by integrating with :sys.trace, allowing for detailed snapshots of a GenServer's internal state as it evolves. Complementing this is the CodeTracer, which captures function call and return events, enabling module-specific instrumentation also utilizing :dbg. All data collected by these core components is channeled into the TraceDB, forming a centralized repository for runtime information.

#### **Data Management: In-memory Storage (ETS), Querying, and Time-Travel Concepts**

A cornerstone of ex\_dbg's architecture is its TraceDB, which serves as the central data store. This database primarily utilizes Erlang Term Storage (ETS) tables—specifically :elixir\_scope\_events, :elixir\_scope\_states, and :elixir\_scope\_process\_index—for in-memory storage. The selection of ETS underscores a strong emphasis on achieving low-latency, high-throughput data access, which is paramount for interactive debugging and responsive "time-travel" queries. This design choice highlights a prioritization of immediate, interactive debugging over long-term archival or large-scale distributed data warehousing, although optional disk persistence is noted for some data.

A dedicated QueryEngine provides high-level interfaces to interact with the TraceDB, enabling powerful "time-travel debugging" capabilities. This allows users to reconstruct the state of processes and events at specific historical timestamps, providing a unique perspective on program execution. The system also incorporates robust data management features, including sampling logic to control the volume of collected data, event formatting for consistency, and cleanup mechanisms that prune the oldest events when predefined limits (e.g., max\_events) are reached. The explicit detailing of tracing\_level and sample\_rate configurations within ex\_dbg's architecture further emphasizes a strong focus on performance management and production-friendliness. This is a critical design consideration for any observability tool intended for live systems, as it allows users to balance the level of detail captured with the associated performance overhead. The "Critical events bypass" feature for sampling ensures that essential information, such as process crashes or exits, is always captured regardless of the configured sampling rates, reinforcing its suitability for production environments.

#### **Advanced Features: AI Integration for Natural Language Debugging**

A standout feature of ex\_dbg is its integration with an external AI system, Tidewave. This AIIntegration module registers nine specific tools (functions) with Tidewave, effectively providing a natural language interface for debugging. Users can leverage these tools to query state timelines, analyze state changes, examine message flows, trace specific processes, and more, all through natural language commands.

The inclusion of tools like analyze\_state\_changes suggests a move beyond mere data display towards automated root-cause analysis and pattern detection. This positions ex\_dbg not just as a data collection and querying utility, but as an intelligent assistant for debugging. This capability could significantly reduce the cognitive load on developers by proactively identifying anomalies or summarizing complex interactions, marking a considerable advancement beyond traditional debugging tools. This feature represents a forward-looking approach, anticipating the increasing role of AI in software development by actively assisting in understanding and diagnosing runtime behavior.

#### **Architectural Overview and Key Components**

The DIAGS.md provides a clear, layered architectural blueprint for ex\_dbg. It delineates a Main Entry Point (ElixirScope), which orchestrates the system. Beneath this lies the Core Data Collection Layer, encompassing ProcessObserver, MessageInterceptor, StateRecorder, and CodeTracer. The collected data then flows into the Storage & Query Layer, comprising TraceDB and QueryEngine. Finally, an Integration Layer handles external connections, including AIIntegration and PhoenixTracker. This modular design promotes a clear separation of concerns, enhancing maintainability and extensibility. The Module Dependencies & Interactions diagram further illustrates how these components interact and rely on underlying BEAM primitives such as GenServer, :dbg, ETS, and :sys. This unified approach to diverse BEAM tracing mechanisms, abstracting away the complexities of individual primitives, provides a consistent and simplified API for developers, thereby reducing the learning curve and operational overhead associated with leveraging multiple low-level Erlang tools.

### **3\. Comparative Analysis of Existing Open-Source Tools**

An examination of the open-source landscape for Elixir and Erlang observability and debugging tools reveals a diverse set of offerings, each with its own strengths and limitations when compared to the comprehensive capabilities of ex\_dbg.

#### **3.1. LiveView-Specific Debugging Tools**

**LiveDebugger** is a browser-based tool specifically designed for debugging Phoenix LiveView applications.1 It provides a detailed view of the LiveComponents tree, allows for the inspection of assigns for both LiveViews and LiveComponents, and offers tracing and filtering of their callback executions. Its features include components highlighting and support for a Chrome DevTools extension, making it user-friendly for developers working with LiveView.2 While LiveDebugger excels in providing deep insights into LiveView's component structure and state changes within the browser, it primarily focuses on the frontend-backend interaction specific to LiveView. It does not appear to offer broader BEAM process, message, or general GenServer state tracing beyond the scope of LiveView's assigns, nor does it mention historical data storage or time-travel capabilities for broader application state.2

**TimeTravel** is another specialized tool for Phoenix LiveView, functioning as a record and replay debugger.4 It attaches to Phoenix LiveView telemetry events, recording the socket state (assigns) at each event. This allows developers to replay interactions and observe how assigns change over time using a browser extension with a slider.4 TimeTravel's explicit offering of time-travel debugging for LiveView socket state is a significant feature for understanding UI interactions and state transitions. However, it is described as a "proof-of-concept" with known limitations, such as high memory usage, lack of graceful restoration upon LiveView crashes, and incomplete support for LiveComponent telemetry or handle\_info callbacks.4 Its focus remains exclusively on LiveView socket state, without extending to general GenServer state or BEAM-wide events.

When comparing these tools with ex\_dbg's PhoenixTracker, a divergence in approach becomes apparent. ex\_dbg's PhoenixTracker is designed to instrument Phoenix HTTP requests and LiveView events, storing them within its unified TraceDB. While LiveDebugger and TimeTravel offer specialized LiveView user interfaces and time-travel for assigns, ex\_dbg aims for a more integrated approach where LiveView events are merely one type of event stored alongside all other BEAM events in a single, comprehensive TraceDB. ex\_dbg's QueryEngine and AIIntegration could theoretically query these LiveView events, but the specific interactive UI/UX for LiveView "time-travel" found in TimeTravel is not explicitly detailed for ex\_dbg. This suggests that ex\_dbg provides a more backend-centric view of LiveView events, whereas LiveDebugger and TimeTravel are more developer-facing, browser-integrated tools. This distinction highlights that while ex\_dbg can capture the necessary data, it may not offer the same specialized, interactive LiveView visualizations that these dedicated tools provide, potentially necessitating a combination of tools for a complete LiveView debugging experience.

#### **3.2. General BEAM Tracing and Debugging Tools**

**Erlang Doctor** is a lightweight tracing, debugging, and profiling tool that collects traces in an ETS table, aiming for minimal system impact.6 It allows for querying and analysis of the collected data, and can trace function calls for modules and functions, specific processes, and message events (send/receive).6 Traces are stored in ETS, typically under the name :trace, and include fields such as index, pid, event type (call, return, exception, send, recv), mfa, data, and timestamp.6 While designed to be lightweight, its continuous use in production is considered "risky" but can be managed through short, time-limited tracing bursts.6 A limitation is that while it captures messages, the level of detail on full message content or comprehensive GenServer state changes is not explicitly detailed beyond a generic "data" field for calls/returns.6 It does not offer time-travel debugging or state reconstruction in the manner that ex\_dbg's StateRecorder and QueryEngine do for GenServer states.7

**Rexbug**, an Elixir wrapper for the :redbug Erlang tracing debugger, connects to live Elixir systems to gather information about code execution.8 It can trace entire modules, specific functions, or functions called with particular arguments, capturing function arguments, results, and stack traces. Rexbug also supports process-specific tracing, remote node investigation, and message tracing.8 It is designed to be production-friendly, incorporating sensible limits on trace duration and the number of messages to prevent system overload.8 However, Rexbug primarily focuses on function call tracing and message *events* (send/receive), without explicitly detailing the capture of *full GenServer state changes* or providing a history of states for time-travel or state reconstruction.8

The **Trace Tool Builder (ttb)** is a foundational Erlang tool for constructing custom trace tools. It allows specifying processes for tracing (ttb:p/2), setting trace patterns for functions (ttb:tp, ttb:tpl), and supports message tracing via the send flag.10 Advanced features include sequential tracing, time-constrained tracing, overload protection, and autoresuming capabilities.10 Ttb writes trace messages to binary files and a .ti information file, and supports wrap logs for managing trace log size. It can format binary logs into readable text or visualize them graphically using et\_viewer in the Event Tracer application, which can display processes, modules, functions, and their interactions as sequence diagrams.10 Despite these capabilities, the documentation does not explicitly state the capture of *full GenServer state changes* or *complete message content* (beyond message events), nor does it offer direct support for time-travel debugging or state reconstruction.10

**fprof** is a time profiling tool that uses tracing to a file to minimize runtime performance impact.11 It collects trace data for function calls, returns, process scheduling, process events (e.g., spawn), and garbage collection, with all entries being timestamped.11 The profiling process involves three steps: tracing to a file, profiling the trace file to simulate the call stack and calculate raw profile data, and finally analyzing this data by sorting, filtering, and dumping it in a human-readable text format.11 While effective for profiling time consumption and call counts, fprof is not a general-purpose debugger for inspecting state or message content, and its batch-processing approach is not designed for real-time interactive querying or time-travel.11

When comparing these general BEAM tracing tools with ex\_dbg's ProcessObserver, MessageInterceptor, StateRecorder, and CodeTracer, a critical distinction emerges. ex\_dbg's components collectively aim to provide a *unified* and *structured* capture of diverse BEAM events (process lifecycle, messages, state changes, function calls) into a single TraceDB. Erlang Doctor, Rexbug, and ttb offer similar low-level tracing capabilities, often leveraging the same underlying Erlang trace facility (:dbg, ttb). However, they lack ex\_dbg's integrated StateRecorder for *persistent GenServer state history* and its QueryEngine for time-travel over this combined dataset. This highlights a fundamental gap in open-source tools for comprehensive, time-travel-enabled state inspection across *any* GenServer, a capability that ex\_dbg specifically aims to fill. The common reliance on core Erlang tracing facilities means that while raw event capture is powerful, the interpretation, storage, and querying of *historical GenServer state* for time-travel debugging remains a distinct and largely unaddressed capability in the open-source landscape, requiring significant engineering effort in instrumentation, data serialization, and a sophisticated query layer.

| Feature / Tool | Process Observation (Lifecycle, Supervision Tree) | Message Interception (Content, Flow) | GenServer State Recording (History, Snapshots) | Function Call Tracing (Args, Returns, Stack) | LiveView/Phoenix Integration (Assigns, Events) | Time-Travel Debugging (Generalized) | AI Integration (Natural Language Querying) | Unified Event/State Storage (ETS/In-memory) | Query Engine (Time-based, PID-based, Type-based) | Configurable Tracing Levels | Sampling Capabilities | Production-Friendliness / Overhead Management | Distributed Tracing Focus |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| **ex\_dbg** | Yes (PO) | Yes (MI, content) | Yes (SR, history) | Yes (CT, args, returns, stack) | Yes (PT, events) | Yes | Yes | Yes (TraceDB via ETS) | Yes | Yes | Yes | High (configurable) | No |
| LiveDebugger | No | No | Limited (LiveView assigns only) | No | Yes (UI, assigns, callbacks) | Limited (LiveView assigns only) | No | No (browser-based) | No | No | No | High (dev-focused) | No |
| TimeTravel | No | No | Limited (LiveView assigns only) | No | Yes (UI, assigns, events) | Yes (LiveView assigns only) | No | No (browser-based) | No | No | No | Low (proof-of-concept, memory issues) | No |
| Erlang Doctor | Yes (process events) | Yes (send/recv events) | Limited (no explicit state history) | Yes (args, returns, stack) | No | No | No | Yes (ETS) | Yes (filter, select, tracebacks) | No | No | Moderate (lightweight, but risky in prod) | No |
| Rexbug | Yes (process-specific) | Yes (send/recv events) | No | Yes (args, returns, stack) | No | No | No | No | No | No | Yes (time, msgs limits) | High (production-friendly limits) | No |
| ttb (Trace Tool Builder) | Yes (ttb:p) | Yes (send flag) | No | Yes (ttb:tp, ttb:tpl) | No | No | No | Yes (binary files) | Limited (text/graphical formatting) | No | No | Moderate (overload protection) | No |
| OpenTelemetry (Erlang/Elixir) | Yes (via traces) | Yes (via traces) | No (not explicitly stated) | Yes (via traces/spans) | Yes (Phoenix/Ecto instrumentation) | No | No | External collector | External collector | Yes | Yes | Low (sampling mitigates) | Yes |
| OpenTracing/OTTER | Yes (via spans) | Yes (via spans) | No (not explicitly stated) | Yes (via spans) | No | No | No | ETS buffer, external collector | External collector | No | Yes | Low (filtering mitigates) | Yes |

*Table 1: Feature Comparison Matrix of ex\_dbg vs. Open-Source Alternatives*

#### **3.3. Distributed Tracing and APM Frameworks**

**OpenTelemetry for Erlang/Elixir** is an observability framework providing an API, SDK, and tools for generating and collecting telemetry data, including traces (stable), metrics (in development), and logs (in development).12 It supports Erlang 23+ and Elixir 1.13+, offering instrumentation libraries for popular frameworks like Phoenix and Ecto.12 A core capability is distributed tracing, which monitors the path of a request across different services using spans and trace IDs, supporting context propagation via mechanisms like HTTP headers.12 OpenTelemetry also provides various sampling strategies to manage performance overhead.14 However, the documentation does not explicitly confirm detailed runtime event capture like *full GenServer state changes* or *complete message content* (beyond basic span attributes). Its primary focus is on distributed request flows rather than deep, internal process state inspection or time-travel debugging.12

**OpenTracing/OTTER** (OpenTracing Toolkit for ERlang) is designed to produce, filter, and send span information to trace collectors such as OpenZipkin or Jaeger.7 It defines spans with timestamps, duration, events (logs), key-value tags, trace\_id, span\_id, and parent\_id, crucial for correlating spans across different systems to provide an end-to-end view of a request.7 OTTER offers both pre-filtering and final filtering of spans to manage data volume.7 While it supports distributed tracing, it is not fully OpenTracing compliant in all aspects, and its documentation does not specify the capture of *detailed GenServer state changes* or *full message content*.7 Its primary utility lies in distributed request tracing rather than deep internal process debugging or time-travel.

A clear **paradigm mismatch** exists between ex\_dbg and distributed tracing tools like OpenTelemetry and OTTER. Distributed tracing tools are designed for understanding request flows across service boundaries, offering a high-level view of system interactions through spans. They are excellent for mapping microservice dependencies and identifying latency bottlenecks in a distributed environment.13 In contrast, ex\_dbg focuses on *deep, granular, single-node (or potentially multi-node via explicit tracing) BEAM runtime introspection*. It captures specific process events, message contents, GenServer state changes, and function calls, storing them in a local, queryable database for detailed debugging and time-travel. This suggests that while OpenTelemetry is crucial for understanding distributed system health, it would not replace ex\_dbg's deep, time-travel debugging capabilities for a single Elixir application's internal logic and state. These tools are complementary rather than substitutes, with ex\_dbg acting as a "magnifying glass" for a specific BEAM instance, providing forensic-level detail on internal process interactions and state, while distributed tracing tools offer a "satellite view" of high-level flows across many services.

#### **3.4. AI-Assisted Development Tools**

The current landscape of open-source AI tools for Elixir primarily addresses *development-time* or *static analysis* concerns. **Workik AI** offers assistance for Elixir development, including code generation, debugging (identifying bottlenecks, analyzing crashes, providing real-time fixes), optimization, automation, testing, and concurrency management.15 It supports various Elixir/Erlang frameworks and libraries, focusing on streamlining development workflows.15 **Aspose AI** provides free AI-powered Elixir code commenting and analysis, aiming to transform unclear code into well-documented, readable programs by generating comments and suggesting improvements.17 A blog post by **Sylverstudios** discusses Elixir's unique suitability for AI pair programming, attributing this to its first-class documentation, functional and compiled design, and deeply integrated testing model. It highlights how AI tools can interact with the full application in native tests, obtain structured failures, and iterate without manual debugging.18

Most of these open-source AI tools for Elixir, such as Workik and Aspose, primarily focus on *static code analysis*, *code generation*, *documentation*, or *test generation and analysis*. While Workik mentions "automating debugging" and "analyzing crashes," the specifics of *runtime interaction* with live system data via natural language are not detailed. ex\_dbg's AI integration, as described in its documentation, is distinct: it provides a *natural language interface to query and analyze live, historical runtime data* (e.g., state timelines, message flows, function calls) directly from its TraceDB and QueryEngine. This positions ex\_dbg's AI as a runtime, interactive debugging assistant, rather than primarily a code generation or static analysis tool. This represents a significant functional gap in the open-source ecosystem, as existing AI tools do not directly query and interpret live system state or historical trace data in the same manner. ex\_dbg is pushing the boundary of AI in observability by integrating it directly into the runtime debugging process, enabling a more intuitive and potentially faster diagnostic workflow.

### **4\. Key Differentiators of ex\_dbg and Identified Gaps in Open-Source Ecosystem**

ex\_dbg distinguishes itself through several key capabilities that are largely absent or less comprehensively implemented in existing open-source Elixir/Erlang tools. These differentiators highlight significant gaps in the current ecosystem.

#### **Integrated GenServer State History and Time-Travel Debugging (beyond LiveView)**

ex\_dbg's StateRecorder is specifically designed to track GenServer state changes, and its QueryEngine facilitates "time-travel debugging" by enabling the retrieval of state timelines and the reconstruction of state at arbitrary timestamps. This is a core feature for understanding the evolution of application state over time. The absence of a robust, open-source equivalent for *generalized GenServer state history and time-travel* represents a critical void for debugging complex, stateful Elixir applications. While TimeTravel offers time-travel for LiveView assigns 4, no other general BEAM tracing tool, such as Erlang Doctor, Rexbug, ttb, or OpenTelemetry, explicitly provides a similar, integrated, and queryable *history of arbitrary GenServer states*. Tools like Erlang Doctor capture function call data and message events, but not a persistent, queryable timeline of internal GenServer state changes. While :sys.get\_state/2 allows inspecting the *current* state of a process 20, it does not provide access to historical states or state reconstruction capabilities. This capability is fundamental for understanding race conditions, unexpected state transitions, and intermittent bugs that are notoriously difficult to reproduce, making ex\_dbg's explicit focus on this area a response to a significant and unmet need in the open-source BEAM observability space.

#### **Comprehensive, Persistent, and Queryable Event/State Database (TraceDB)**

ex\_dbg's TraceDB functions as a central repository for all collected events—including process lifecycle events, message content, state changes, function calls, and Phoenix events—all stored within ETS tables. This design ensures that the data is highly queryable via the QueryEngine, supporting various filters (by PID, type, or time) and enabling complex time-based queries. This unified data model significantly simplifies debugging by eliminating the need to manually correlate information across multiple tools or log files. While Erlang Doctor also uses ETS for traces 6 and OpenTelemetry collects traces and logs 12, none offer the same *unified schema* for all BEAM events (including detailed GenServer state) combined with a sophisticated, integrated *query engine* for time-travel and complex filtering across this diverse dataset. Most existing tools either specialize in specific event types or provide raw logs and traces that necessitate external processing for deep analysis, making ex\_dbg's TraceDB and QueryEngine a unique and valuable contribution to BEAM runtime observability.

#### **Direct AI-Driven Natural Language Interface for Runtime Analysis**

The AIIntegration module in ex\_dbg registers nine specific tools with an external AI system (Tidewave), facilitating natural language queries for runtime data analysis, such as "get state timeline," "analyze state changes," and "get message flow". This represents a significant advancement in debugging interfaces, shifting from command-line or GUI-driven queries to natural language interaction. As discussed previously, existing open-source AI tools for Elixir primarily focus on code generation, static analysis, or testing, with limited capabilities for direct, interactive natural language querying and analysis of *live or historical runtime trace and state data*.15 This functional distinction means that ex\_dbg's AI acts as an intelligent interpreter and query builder for runtime data, making debugging more intuitive and efficient. This lowers the barrier to entry for complex debugging tasks and accelerates the diagnostic process, positioning ex\_dbg at the forefront of AI integration in observability.

#### **Unified Approach to Diverse BEAM Tracing Mechanisms**

ex\_dbg integrates various BEAM tracing mechanisms, including :dbg for messages and functions, :sys.trace for GenServer states, and telemetry for Phoenix events, all accessible through a single ElixirScope.setup/1 API. This approach normalizes diverse data into a unified format for TraceDB. In contrast, existing open-source tools often specialize in one or two tracing mechanisms or data types; for example, fprof is for profiling, ttb for low-level traces, and OpenTelemetry for spans. There is no single open-source library that aggregates and normalizes these disparate BEAM tracing outputs into a coherent, queryable data store for holistic debugging. ex\_dbg effectively acts as a centralized orchestration layer for BEAM observability. By abstracting away the complexities and idiosyncrasies of different BEAM tracing primitives, it provides a consistent and simplified API for developers, thereby reducing the learning curve and operational overhead associated with leveraging multiple low-level Erlang tools. This architectural choice addresses a common pain point in BEAM debugging: the fragmentation of tracing tools.

### **5\. Recommendations for Achieving ex\_dbg-like Functionality with Open-Source Software**

Achieving the comprehensive, integrated debugging and observability capabilities of ex\_dbg using only existing open-source tools in the Elixir/Erlang ecosystem presents a significant challenge. This is due to ex\_dbg's unique combination of features, particularly its generalized GenServer state history, unified queryable event store, and direct AI integration. A multi-pronged strategy, combining existing tools with targeted custom development, is therefore recommended.

#### **5.1. Strategy 1: Combining Existing Tools**

To approximate ex\_dbg's feature set, a combination of specialized open-source tools would be necessary.

* **For Process, Message, and Function Call Tracing (similar to ProcessObserver, MessageInterceptor, CodeTracer):**  
  * **Erlang Doctor** can be utilized for lightweight tracing of function calls across modules, specific processes, and for capturing message events (send/recv). Its ability to store traces in ETS and offer querying capabilities, along with msg\_trigger and limit options, provides a degree of production-friendly control.6  
  * **Rexbug**, as an Elixir wrapper for :redbug, offers similar function call and message tracing, complete with production-friendly limits on trace duration and message count. It is also capable of investigating remote nodes.8  
  * For more advanced, system-level tracing, including time-constrained tracing, overload protection, and graphical visualization via et\_viewer, the **Trace Tool Builder (ttb)** would be a suitable choice. It allows detailed control over trace flags and patterns.10  
  * *Analysis:* While these tools cover the raw event capture aspect, they lack the unified TraceDB and QueryEngine that ex\_dbg offers for integrated historical analysis across all event types.  
* **For LiveView/Phoenix Integration (similar to PhoenixTracker):**  
  * **LiveDebugger** provides a browser-based user interface for inspecting the LiveComponents tree, assigns, and tracing callback executions, offering a rich interactive experience for LiveView-specific debugging.1  
  * **TimeTravel** offers record/replay and time-travel debugging specifically for LiveView socket state (assigns) via a browser extension and slider, which is invaluable for understanding UI state transitions.4  
  * **OpenTelemetry Erlang/Elixir** with its Phoenix instrumentation can capture Phoenix-related telemetry events (HTTP requests, LiveView events) as part of distributed traces and logs, providing structured event data.12  
  * *Analysis:* LiveDebugger and TimeTravel offer the interactive UI/UX for LiveView that ex\_dbg may not explicitly provide in its current description, but their scope is limited to the LiveView context. OpenTelemetry provides structured events but not necessarily the interactive debugging experience.  
* **For General Application Performance Monitoring (APM) and Distributed Tracing:**  
  * **OpenTelemetry Erlang/Elixir** stands as the standard for distributed tracing, metrics, and logs. It provides instrumentation for common Elixir libraries (Phoenix, Ecto, Oban) via telemetry and is essential for achieving end-to-end visibility across microservices.12  
  * **OpenTracing/OTTER** serves as an alternative for span-based distributed tracing, although OpenTelemetry is the currently recommended standard for new implementations.7  
  * *Analysis:* These tools provide the crucial distributed context that ex\_dbg does not explicitly focus on, but they lack the deep, internal BEAM process state history and time-travel capabilities that ex\_dbg emphasizes.  
* **Integration Challenges and Potential Workarounds:**  
  * A significant challenge with combining these tools is the creation of **data silos**. Each tool collects data in its own format and stores it in its preferred backend (e.g., ETS for Erlang Doctor, files for ttb/fprof, external collectors for OpenTelemetry). Correlating events across these disparate sources to achieve a holistic view, similar to ex\_dbg's TraceDB, would require substantial manual effort or the development of custom aggregation layers.  
  * **Unified querying** remains a major hurdle. There is no single open-source query engine capable of spanning the diverse data collected by all these tools to provide ex\_dbg-like time-travel and complex filtering capabilities.  
  * Managing the **cumulative performance overhead** of multiple simultaneous tracing tools can also be complex, even if individual tools offer performance controls.  
  * *Workaround:* A potential solution involves implementing a custom "telemetry sink." This sink would subscribe to various BEAM events (e.g., from telemetry for Phoenix/Ecto, from dbg via a wrapper, from sys.trace for GenServers) and normalize them into a single, custom ETS-based store. This would essentially entail building a simplified version of ex\_dbg's TraceDB and QueryEngine from scratch.

#### **5.2. Strategy 2: Extending Existing Tools or Custom Development**

Given the identified gaps, particularly in generalized GenServer state history, a unified queryable data store, and direct AI integration, significant custom development or extension of existing tools would be necessary.

* **Identification of Specific Components that Would Require Custom Development:**  
  * **Generalized GenServer State History Module:** This is arguably the most significant functional gap. A custom module would need to be developed to instrument GenServers, perhaps via \_\_using\_\_ macros or sys.trace hooks, to capture state *before* and *after* each callback. This module would also need to efficiently serialize and deserialize GenServer states, and store these state snapshots in a persistent, queryable manner, possibly in a custom ETS table or a specialized database. Crucially, it would require APIs for retrieving state timelines and reconstructing state at arbitrary timestamps.  
  * **Unified Event/State Query Layer:** To replicate ex\_dbg's QueryEngine, a custom query layer would be essential. This layer would need to query across all collected event types (process, message, function, state, Phoenix) and provide time-travel capabilities. This would involve developing complex ETS matching logic or integrating with an external database that supports such queries.  
  * **AI Integration Layer:** Developing a natural language interface for runtime analysis would necessitate:  
    * Integration with a Large Language Model (LLM), either via a local model or an external API (e.g., OpenAI, given Tidewave is an external system).  
    * Defining "tools" (functions) that the LLM can invoke to interact with the custom query layer.  
    * Careful prompt engineering to enable effective natural language querying and analysis of trace data.  
    * Implementing data summarization and sanitization to prevent verbose LLM responses and handle potentially sensitive information.  
  * **Unified Tracing Orchestration:** A custom top-level module, analogous to ElixirScope, would be required to configure and start all underlying tracing mechanisms and the custom data store, presenting a single, coherent API for developers.  
* **Considerations for Performance Overhead, Data Storage, and Maintenance in a Hybrid Approach:**  
  * **Overhead:** Deep tracing, especially of GenServer state, can introduce substantial performance overhead. Implementing configurable tracing\_level options (e.g., :full, :minimal, :off) and sample\_rate controls (e.g., 0.0-1.0), similar to ex\_dbg's Section 6, is crucial for managing this impact. Performance testing in production-like environments is essential to ensure operational viability.14  
  * **Data Storage:** While ETS offers high speed for in-memory operations, it has inherent limitations for long-term or very large-scale data storage. For persistence or distributed scenarios, considering external databases (e e.g., Mnesia for distributed ETS-like capabilities, or a time-series database) would be necessary. ex\_dbg's mention of "Optional disk storage" acknowledges this need for persistence.  
  * **Maintenance:** A custom solution, particularly one combining multiple open-source tools and bespoke components, will require significant ongoing maintenance. This includes adapting to new BEAM/Elixir versions, changes in underlying tracing APIs, and continuous development to match evolving debugging needs. This represents a substantial engineering commitment.

#### **5.3. General Best Practices**

* Importance of Configurable Tracing Levels and Sampling:  
  Any custom or combined observability solution must prioritize configurable tracing levels (e.g., :full for maximum detail, :minimal for critical events only, or :off for zero active tracing) and sampling rates (from 0.0 to 1.0) to effectively manage performance overhead in production environments. It is paramount that critical events, such as process spawns, exits, or crashes, are always captured regardless of the sampling rate, ensuring that essential information for post-mortem analysis is never lost. The ability to dynamically adjust tracing granularity and sampling is crucial for striking a balance between the depth of observability and the impact on system performance in live systems. This approach, explicitly designed into ex\_dbg and observed in mature APM tools like Scout APM 23, transforms a deep tracing tool from a development-only utility into a robust, production-ready solution.  
* Leveraging telemetry for Instrumentation:  
  For new instrumentation or when integrating with existing libraries, leveraging Elixir's telemetry library is a modern and highly recommended practice. Many popular Elixir packages, including Phoenix, Ecto, LiveView, and Oban, already emit structured telemetry events.3 Building upon telemetry allows custom solutions to achieve broad instrumentation with minimal effort and benefit from a consistent event format, rather than relying solely on lower-level, more intrusive BEAM tracing primitives for application-specific events. telemetry serves as a standardized, low-overhead event bus for application-level events. Integrating with telemetry is highly efficient for a custom solution, as it enables the capture of structured events from a wide range of popular libraries without requiring custom instrumentation for each. These structured events simplify their ingestion into a unified data store, complementing lower-level BEAM tracing (such as :dbg for messages and functions) by providing valuable application-specific context. Adhering to telemetry ensures that a custom observability solution aligns well with the broader Elixir ecosystem, facilitating easier integration with existing and future libraries.

### **Conclusions**

The analysis unequivocally demonstrates that ex\_dbg presents a uniquely integrated and comprehensive debugging and observability framework for Elixir, particularly distinguished by its generalized GenServer state history with time-travel capabilities, its unified and queryable event/state database (TraceDB), and its innovative direct AI-driven natural language interface for runtime analysis. These features collectively offer a level of deep, interactive BEAM runtime introspection that is not currently matched by any single open-source tool.

While the open-source ecosystem provides a rich array of specialized tools—ranging from LiveView-specific debuggers (LiveDebugger, TimeTravel) to general BEAM tracers (Erlang Doctor, Rexbug, ttb, fprof) and distributed tracing frameworks (OpenTelemetry, OpenTracing/OTTER)—each addresses only a subset of ex\_dbg's comprehensive functionality. Significant gaps exist, particularly in the ability to maintain a persistent, queryable history of *any* GenServer's state changes, to unify diverse BEAM event streams into a single, queryable data model, and to enable natural language interaction for runtime debugging.

Therefore, for organizations seeking to achieve ex\_dbg-like capabilities using open-source software, a multi-faceted approach is not merely an option but a necessity. This would involve a strategic combination of existing specialized tools to cover various aspects of tracing and monitoring. Crucially, substantial custom development would be required to bridge the identified functional voids, particularly in implementing a robust GenServer state history module, building a unified query layer over heterogeneous data sources, and developing an AI integration layer for natural language runtime analysis.

Any such hybrid or custom solution must rigorously adhere to best practices for production-readiness, including the implementation of configurable tracing levels and sampling rates to manage performance overhead. Furthermore, leveraging Elixir's telemetry library for instrumentation across application components is vital for consistent, low-overhead event capture and seamless integration within the broader Elixir ecosystem. In essence, while individual components of ex\_dbg's functionality can be found in various open-source projects, replicating its holistic, integrated, and intelligent approach demands a significant investment in custom engineering and careful architectural planning.

| Tracing Approach/Tool | Primary Mechanism | Typical Overhead | Key Mitigations | Data Persistence | Primary Use Case |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **ex\_dbg** | :dbg, :sys.trace, Telemetry, ETS | Low-High | Tracing levels, sample rate, critical event bypass | In-memory (ETS), Optional Disk | Dev/Prod Debugging, Analysis |
| LiveDebugger | Phoenix LiveView Telemetry, Browser JS | Low | N/A | Browser Storage | LiveView Dev Debugging |
| TimeTravel | Phoenix LiveView Telemetry, Browser JS | Moderate | Manual storage clear | Browser Storage | LiveView Time-Travel Debugging |
| Erlang Doctor | Erlang Trace Facility, ETS | Low-Moderate | Time/trace limits | In-memory (ETS), File | Dev Debugging, Profiling |
| Rexbug | :redbug (Erlang Trace Facility) | Low-Moderate | Time/message limits | Console/File | Dev Debugging, Live System Tracing |
| ttb | Erlang Trace Facility | Moderate | Overload protection, time-constrained tracing | Binary Files | System Tracing, Analysis |
| OpenTelemetry | Telemetry, Spans, Metrics, Logs | Low | Probabilistic/parent-based sampling | External Collector | Distributed Tracing, APM |
| OpenTracing/OTTER | Spans, ETS buffer, HTTP/Thrift | Low | Pre-filtering, final filtering | ETS buffer, External Collector | Distributed Tracing |
| Scout APM | Agent-based instrumentation | Minimal (\<1%) | Efficient metric collection, secure transmission | External SaaS Backend | Production APM |

*Table 2: Conceptual Performance Overhead Comparison of ex\_dbg and Various Open-Source Tools*

#### **Works cited**

1. LiveDebugger: tool for debugging LiveView apps : r/elixir \- Reddit, accessed May 21, 2025, [https://www.reddit.com/r/elixir/comments/1izinfw/livedebugger\_tool\_for\_debugging\_liveview\_apps/](https://www.reddit.com/r/elixir/comments/1izinfw/livedebugger_tool_for_debugging_liveview_apps/)  
2. software-mansion/live-debugger: Tool for debugging ... \- GitHub, accessed May 21, 2025, [https://github.com/software-mansion/live-debugger](https://github.com/software-mansion/live-debugger)  
3. newrelic/elixir\_agent: New Relic's Open Source Elixir Agent \- GitHub, accessed May 21, 2025, [https://github.com/newrelic/elixir\_agent](https://github.com/newrelic/elixir_agent)  
4. TimeTravel \- A Record/Replay debugger for LiveView \- Libraries \- Elixir Forum, accessed May 21, 2025, [https://elixirforum.com/t/timetravel-a-record-replay-debugger-for-liveview/52333](https://elixirforum.com/t/timetravel-a-record-replay-debugger-for-liveview/52333)  
5. JohnnyCurran/TimeTravel: Phoenix LiveView TimeTravel ... \- GitHub, accessed May 21, 2025, [https://github.com/JohnnyCurran/TimeTravel](https://github.com/JohnnyCurran/TimeTravel)  
6. chrzaszcz/erlang\_doctor: Lightweight tracing, debugging ... \- GitHub, accessed May 21, 2025, [https://github.com/chrzaszcz/erlang\_doctor](https://github.com/chrzaszcz/erlang_doctor)  
7. opentracing-contrib/opentracing-erlang: Open Tracing ... \- GitHub, accessed May 21, 2025, [https://github.com/opentracing-contrib/opentracing-erlang](https://github.com/opentracing-contrib/opentracing-erlang)  
8. nietaki/rexbug: A thin Elixir wrapper for the redbug Erlang ... \- GitHub, accessed May 21, 2025, [https://github.com/nietaki/rexbug](https://github.com/nietaki/rexbug)  
9. rexbug v1.0.6 \- HexDocs, accessed May 21, 2025, [https://hexdocs.pm/rexbug/Rexbug.html](https://hexdocs.pm/rexbug/Rexbug.html)  
10. Erlang \-- Trace Tool Builder, accessed May 21, 2025, [https://erlang.org/documentation/doc-5.9.3/lib/observer-1.2/doc/html/ttb\_ug.html](https://erlang.org/documentation/doc-5.9.3/lib/observer-1.2/doc/html/ttb_ug.html)  
11. fprof — tools v4.1.1 \- Erlang, accessed May 21, 2025, [https://www.erlang.org/doc/apps/tools/fprof.html](https://www.erlang.org/doc/apps/tools/fprof.html)  
12. Erlang/Elixir | OpenTelemetry, accessed May 21, 2025, [https://opentelemetry.io/docs/languages/erlang/](https://opentelemetry.io/docs/languages/erlang/)  
13. Distributed tracing in Kubernetes apps: What you need to know | CNCF, accessed May 21, 2025, [https://www.cncf.io/blog/2023/03/29/distributed-tracing-in-kubernetes-apps-what-you-need-to-know/](https://www.cncf.io/blog/2023/03/29/distributed-tracing-in-kubernetes-apps-what-you-need-to-know/)  
14. Integrating OpenTelemetry with Elixir: A Step-by-Step Guide | Last9, accessed May 21, 2025, [https://last9.io/blog/opentelemetry-with-elixir/](https://last9.io/blog/opentelemetry-with-elixir/)  
15. FREE AI-Powered Elixir Code Generator: Try AI Assistance \- Workik, accessed May 21, 2025, [https://workik.com/elixir-code-generator](https://workik.com/elixir-code-generator)  
16. FREE AI Erlang Code Generator – Build Fault-Tolerant, Scalable Systems Easily \- Workik, accessed May 21, 2025, [https://workik.com/erlang-code-generator](https://workik.com/erlang-code-generator)  
17. AI Elixir Code Commenting Tool | Automatic Documentation Generator for Readable, Maintainable Code \- Free AI Agents for a Variety of File Formats, accessed May 21, 2025, [http://products.aspose.ai/total/ai-code-analysis/elixir/](http://products.aspose.ai/total/ai-code-analysis/elixir/)  
18. Elixir's Advantage in the Era of AI \- Sylver Studios, accessed May 21, 2025, [https://sylverstudios.dev/blog/2025/03/25/elixir-ai](https://sylverstudios.dev/blog/2025/03/25/elixir-ai)  
19. Why Elixir is the Best Runtime for Building Agentic Workflows \- Freshcode, accessed May 21, 2025, [https://www.freshcodeit.com/blog/why-elixir-is-the-best-runtime-for-building-agentic-workflows](https://www.freshcodeit.com/blog/why-elixir-is-the-best-runtime-for-building-agentic-workflows)  
20. GenServer behaviour (Elixir v1.18.3) \- HexDocs, accessed May 21, 2025, [https://hexdocs.pm/elixir/GenServer.html](https://hexdocs.pm/elixir/GenServer.html)  
21. Is there a way to access the state of a GenServer? \- Stack Overflow, accessed May 21, 2025, [https://stackoverflow.com/questions/49195034/is-there-a-way-to-access-the-state-of-a-genserver](https://stackoverflow.com/questions/49195034/is-there-a-way-to-access-the-state-of-a-genserver)  
22. Best way to log request details (path, response time, etc.) for metrics & observability in a Phoenix app? : r/elixir \- Reddit, accessed May 21, 2025, [https://www.reddit.com/r/elixir/comments/1jl2org/best\_way\_to\_log\_request\_details\_path\_response/](https://www.reddit.com/r/elixir/comments/1jl2org/best_way_to_log_request_details_path_response/)  
23. Elixir & Phoenix Performance Monitoring \- Scout APM, accessed May 21, 2025, [https://www.scoutapm.com/agents/elixir-phoenix-monitoring](https://www.scoutapm.com/agents/elixir-phoenix-monitoring)  
24. Elixir performance monitoring for Phoenix, Oban, and more \- Honeybadger.io, accessed May 21, 2025, [https://www.honeybadger.io/blog/elixir-performance-monitoring/](https://www.honeybadger.io/blog/elixir-performance-monitoring/)
